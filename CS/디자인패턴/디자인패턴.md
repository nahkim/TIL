# 디자인 패턴





## 전략 패턴 (Strategy Pattern)

객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능

전략 패턴은 정책 패턴(policy pattern)이라고도 함

객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트  안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

컨텍스트

​	전략 -> A, B, C

* 컨텍스트 : 상황, 맥락, 문맥을 의미(개발자가 어떠한 작업을 완료하는데 필요한 모든 관련 정보를 말함)

ex) 카드 결제 방법, Node.js의 passport라이브러리(LocalStrategy, OAuth)

특징
OCP에 위배되지 않는다.

코드 확장시 중복 상황을 제거한다.



* OCP(Open-Closed Principle) 개방-폐쇄 원칙
  * 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.


수행하는 작업

- Strategy: 인터페이스나 추상 클래스로 외부에서 동일한 방식으로 알고리즘을 호출하는 방법을 명시
- ConcreteStrategy1, ConcreteStrategy2, ConcreteStrategy3 : 스트래티지 패턴에서 명시한 알고리즘을 실제로 구현한 클래스
- Context : 스트래티지 패턴을 이용하는 역할을 수행, 필요에 따라 도적으로 구체적인 전략을 바꿀 수 있도록 setter 메서드를 제공

클라이언트가 원하는 스트래티지 객체 생성

이를 Context 객체에 바인딩

Context 객체는 바인딩된 스트래티지 객체의 타입에 따라 적절한 행의를 실행함


## 옵저버 패턴

observer pattern

주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

여기서 주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미, 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 함

주로 이벤트 기반 시스템에 사용

ex) 트위터, MVC 패턴

## 이터레이터 패턴(반복자 패턴)

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

순회할 수 있는 여러가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능

## 노출모듈 패턴

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

자바스크립트의 경우 private, public과 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행된다. 그렇기 때문에 노출 모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 한다.

**public**

클래스에 정의된 함수에서 접근 가능, 자식 클래스와 외부 클래스에서 접근 가능

**protected**

클래스에 정의된 함수에서 접근 가능, 자식 클래스에선 접근 가능하지만, 외부 클래스에서 접근 불가능

**private**

클래스에 정의된 함수에서 접근 가능, 자식 클래스와 외부 클래스에서 접근 불가능

**즉시 실행 함수**

초기화 코드

## MVC 패턴

모델, 뷰, 컨트롤러로 이루어진 디자인 패턴

애플리케이션의 구성 요소를 세가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있음

재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있음

모델

애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함

사각형 모양의 박스 안에 글자가 들어 있다면 그 사각형 모양의 박스 위치 정보, 글자 내용, 글자 위치, 글자 포맷(utf-8등)에 관한 정보를 모두 가지고 있어야함.

뷰에서 데이터를 생성학나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함

ex) 리액트

뷰

inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타냄

죽, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻함.

모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고있어야함, 또한 변경이 일어나면 컨트롤러에 이를 전달해야함

컨트롤러

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며, 이벤트 등 메인 로직을 담당. 또한 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌

## MVP 패턴

MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터로 교체된 패턴

뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있음

## MVVM패턴

MVC의 C에 해당하는 컨트롤러가 뷰모델로 바뀐 패턴

뷰모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징

뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며, UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있음

ex) vue

## 템플릿 패턴

전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 메서드의 코드 중복을 최소화할때 유용함

동일한 기능을 상위 클래스에서 정의하면서 확장/변화가 필요한 부분만 서브 클래스에서 구현할 수 있도록 함

ex) 자율주행 자동차와 사람이 운전하는 자동차, 삼성 모니터와 LG 모니터

추상 메서드 : 알고리즘에서 특정 단계를 제공해야만 하는 경우 사용

Hook 메서드 : 알고리즘의 특정 부분이 선택적으로 사용하는 경우 사용
